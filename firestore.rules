rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function signedIn() { return request.auth != null; }

    // Treat the account that owns username "admin" as an admin, and also
    // support an explicit custom claim (request.auth.token.admin).
    function adminUidFromUsername() {
      return exists(/databases/$(database)/documents/usernames/admin)
        ? get(/databases/$(database)/documents/usernames/admin).data.uid
        : '';
    }
    function isAdmin() {
      return signedIn() && (request.auth.token.admin == true || request.auth.uid == adminUidFromUsername());
    }

    // ===== user profiles / username registry =====
    match /usernames/{username} {
      allow read: if true;

      // Claim a username once (no overwrites). Username doc id is the normalized username.
      allow create: if signedIn()
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.authHandle is string
        && username.matches('^[a-z0-9_]{3,20}$')
        && !exists(/databases/$(database)/documents/usernames/$(username));

      // Registry docs should be immutable after creation. Users may delete their
      // own username doc during account deletion / rename; admins may delete for cleanup.
      allow update: if false;
      allow delete: if isAdmin() || (signedIn() && request.auth.uid == resource.data.uid);
    }

    match /users/{uid} {
      allow read: if signedIn() && (request.auth.uid == uid || isAdmin());
      allow create, update: if signedIn() && request.auth.uid == uid;
      allow delete: if isAdmin() || (signedIn() && request.auth.uid == uid);
    }

    // ===== players =====
    match /players/{uid} {
      allow read: if signedIn();
      allow create: if signedIn() && request.auth.uid == uid;
      // Players can update their own profile. We also allow any signed-in user
      // to update another player's *invites* field (and updatedAt) so that any
      // team member can send/cancel invites. This app is intentionally
      // lightweight and does not implement fine-grained invite ACLs.
      allow update: if signedIn() && (
        request.auth.uid == uid
        || isAdmin()
        || request.resource.data.diff(resource.data).affectedKeys().hasOnly(['invites', 'updatedAt'])
      );
      allow delete: if isAdmin() || (signedIn() && request.auth.uid == uid);
    }

    // ===== teams =====
    match /teams/{teamId} {
      allow read: if signedIn();
      allow create: if signedIn() && request.resource.data.creatorUserId == request.auth.uid;
      function uidListed(listValue) {
        return (listValue is list) && listValue.hasAny([request.auth.uid]);
      }
      // Firestore Rules does not support JS-style lambdas (m => m.userId).
      // Teams are small; scan a bounded number of roster entries.
      function rosterEntryHasAuthUid(roster, i) {
        return roster.size() > i
          && roster[i] is map
          && roster[i].get('userId', '') == request.auth.uid;
      }
      function rosterHasAuthUid(roster) {
        return (roster is list) && (
          rosterEntryHasAuthUid(roster, 0)  || rosterEntryHasAuthUid(roster, 1)
          || rosterEntryHasAuthUid(roster, 2)  || rosterEntryHasAuthUid(roster, 3)
          || rosterEntryHasAuthUid(roster, 4)  || rosterEntryHasAuthUid(roster, 5)
          || rosterEntryHasAuthUid(roster, 6)  || rosterEntryHasAuthUid(roster, 7)
          || rosterEntryHasAuthUid(roster, 8)  || rosterEntryHasAuthUid(roster, 9)
          || rosterEntryHasAuthUid(roster, 10) || rosterEntryHasAuthUid(roster, 11)
          || rosterEntryHasAuthUid(roster, 12) || rosterEntryHasAuthUid(roster, 13)
          || rosterEntryHasAuthUid(roster, 14) || rosterEntryHasAuthUid(roster, 15)
        );
      }
      function isTeamMember(teamData) {
        return signedIn() && (
          teamData.get('creatorUserId', '') == request.auth.uid
          || uidListed(teamData.get('memberIds', []))
          || rosterHasAuthUid(teamData.get('members', []))
        );
      }
      // Allow non-members to request/cancel by only touching the pending list.
      function isSelfPendingOnlyUpdate() {
        return signedIn()
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pending', 'updatedAt'])
          && (
            // must be present in either the old or new pending list
            uidListed(resource.data.get('pendingIds', []))
            || uidListed(request.resource.data.get('pendingIds', []))
            || rosterHasAuthUid(resource.data.get('pending', []))
            || rosterHasAuthUid(request.resource.data.get('pending', []))
          );
      }
      // Allow a user to join a team by adding themselves to members (invite accept).
      function isSelfJoinUpdate() {
        return signedIn()
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'pending', 'updatedAt'])
          && (
            uidListed(request.resource.data.get('memberIds', []))
            || rosterHasAuthUid(request.resource.data.get('members', []))
          );
      }
      // Members can manage invites/requests and roster. Admin can do anything.
      allow update: if signedIn() && (isAdmin() || isTeamMember(resource.data) || isSelfPendingOnlyUpdate() || isSelfJoinUpdate());
      allow delete: if isAdmin();

      match /chat/{msgId} {
        allow read: if signedIn();
        allow create: if signedIn() && request.resource.data.senderId == request.auth.uid;
        allow update, delete: if isAdmin();
      }
    }

    // ===== team name registry =====
    match /teamNames/{nameKey} {
      allow read: if signedIn();
      // Any signed-in user may write so team create/rename/delete can maintain
      // the uniqueness registry. The app enforces ownership via transactions.
      allow write: if signedIn();
    }

    // ===== global chat =====
    match /globalChat/{msgId} {
      allow read: if signedIn();
      allow create: if signedIn() && request.resource.data.senderId == request.auth.uid;
      allow update, delete: if isAdmin();
    }

    // ===== games (quick play + tournament games) =====
    match /games/{gameId} {
      allow read: if signedIn();
      allow create, update: if signedIn();
      allow delete: if isAdmin();
    }

    // ===== presence =====
    match /presence/{uid} {
      // Public read so "Who's Online" works on the sign-in screen.
      // Writes are still locked to the signed-in owner/admin.
      allow read: if true;
      allow create, update: if signedIn() && request.auth.uid == uid;
      allow delete: if isAdmin() || (signedIn() && request.auth.uid == uid);
    }

    // ===== direct messages (personal chat) =====
    match /dmThreads/{threadId} {
      allow read: if signedIn() && (request.auth.uid in resource.data.participants);
      allow create: if signedIn()
        && (request.auth.uid in request.resource.data.participants)
        && request.resource.data.participants.size() == 2;
      allow update: if signedIn() && (request.auth.uid in resource.data.participants);
      allow delete: if isAdmin() || (signedIn() && (request.auth.uid in resource.data.participants));

      match /messages/{msgId} {
        allow read: if signedIn()
          && exists(/databases/$(database)/documents/dmThreads/$(threadId))
          && (request.auth.uid in get(/databases/$(database)/documents/dmThreads/$(threadId)).data.participants);
        allow create: if signedIn()
          && exists(/databases/$(database)/documents/dmThreads/$(threadId))
          && (request.auth.uid in get(/databases/$(database)/documents/dmThreads/$(threadId)).data.participants)
          && request.resource.data.senderId == request.auth.uid;
        allow update, delete: if isAdmin();
      }
    }

    // ===== admin activity logs =====
    match /logs/{logId} {
      // Only the "admin" user (or a custom-claim admin) can read logs.
      allow read: if isAdmin();
      // Any signed-in user can create a log event, but only for themselves.
      allow create: if signedIn() && request.resource.data.actorId == request.auth.uid;
      allow update, delete: if isAdmin();
    }

    // ===== admin backups =====
    match /adminBackups/{backupId} {
      allow read, write: if isAdmin();
      match /{sub=**} {
        allow read, write: if isAdmin();
      }
    }

    // ===== legacy name registry (disabled) =====
    match /nameRegistry/{docId} {
      allow read, write: if false;
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
